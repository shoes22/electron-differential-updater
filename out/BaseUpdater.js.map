{"version":3,"sources":["../src/BaseUpdater.ts"],"names":[],"mappings":";;;;;;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEM,MAAgB,WAAhB,SAAoC,wBAApC,CAA8C;AAIlD,EAAA,WAAA,CAAsB,OAAtB,EAA0D,GAA1D,EAA0E;AACxE,UAAM,OAAN,EAAe,GAAf;AAJQ,SAAA,oBAAA,GAAuB,KAAvB;AACF,SAAA,gBAAA,GAAmB,KAAnB;AAIP;;AAED,EAAA,cAAc,CAAC,QAAQ,GAAG,KAAZ,EAAmB,eAAe,GAAG,KAArC,EAA0C;AACtD,SAAK,OAAL,CAAa,IAAb,CAAkB,oCAAlB;;AACA,UAAM,WAAW,GAAG,KAAK,OAAL,CAClB,QADkB,EAElB,QAAQ,GAAG,eAAH,GAAqB,IAFX,CAApB;;AAIA,QAAI,WAAJ,EAAiB;AACf,MAAA,YAAY,CAAC,MAAK;AAChB,aAAK,GAAL,CAAS,IAAT;AACD,OAFW,CAAZ;AAGD,KAJD,MAIO;AACL,WAAK,oBAAL,GAA4B,KAA5B;AACD;AACF;;AAES,EAAA,eAAe,CACvB,WADuB,EACU;AAEjC,WAAO,MAAM,eAAN,CAAsB;AAC3B,MAAA,IAAI,EAAE,MAAM,KAAN,IAAc;AAClB,aAAK,wBAAL,CAA8B,KAA9B;AACA,aAAK,cAAL;AACD,OAJ0B;AAK3B,SAAG;AALwB,KAAtB,CAAP;AAOD,GAjCiD,CAsClD;;;AACU,EAAA,OAAO,CAAC,QAAD,EAAoB,eAApB,EAA4C;AAC3D,QAAI,KAAK,oBAAT,EAA+B;AAC7B,WAAK,OAAL,CAAa,IAAb,CACE,2DADF;;AAGA,aAAO,KAAP;AACD;;AAED,UAAM,sBAAsB,GAAG,KAAK,sBAApC;AACA,UAAM,aAAa,GACjB,sBAAsB,IAAI,IAA1B,GAAiC,IAAjC,GAAwC,sBAAsB,CAAC,IADjE;AAEA,UAAM,kBAAkB,GACtB,sBAAsB,IAAI,IAA1B,GACI,IADJ,GAEI,sBAAsB,CAAC,kBAH7B;;AAIA,QAAI,aAAa,IAAI,IAAjB,IAAyB,kBAAkB,IAAI,IAAnD,EAAyD;AACvD,WAAK,aAAL,CACE,IAAI,KAAJ,CAAU,mDAAV,CADF;AAGA,aAAO,KAAP;AACD,KApB0D,CAsB3D;;;AACA,SAAK,oBAAL,GAA4B,IAA5B;;AAEA,QAAI;AACF,WAAK,OAAL,CAAa,IAAb,CACE,sBAAsB,QAAQ,sBAAsB,eAAe,EADrE;;AAGA,aAAO,KAAK,SAAL,CAAe;AACpB,QAAA,aADoB;AAEpB,QAAA,QAFoB;AAGpB,QAAA,eAHoB;AAIpB,QAAA,qBAAqB,EAAE,kBAAkB,CAAC;AAJtB,OAAf,CAAP;AAMD,KAVD,CAUE,OAAO,CAAP,EAAU;AACV,WAAK,aAAL,CAAmB,CAAnB;AACA,aAAO,KAAP;AACD;AACF;;AAES,EAAA,cAAc,GAAA;AACtB,QAAI,KAAK,gBAAL,IAAyB,CAAC,KAAK,oBAAnC,EAAyD;AACvD;AACD;;AAED,SAAK,gBAAL,GAAwB,IAAxB;AAEA,SAAK,GAAL,CAAS,MAAT,CAAgB,QAAQ,IAAG;AACzB,UAAI,KAAK,oBAAT,EAA+B;AAC7B,aAAK,OAAL,CAAa,IAAb,CACE,oEADF;;AAGA;AACD;;AAED,UAAI,QAAQ,KAAK,CAAjB,EAAoB;AAClB,aAAK,OAAL,CAAa,IAAb,CACE,uFAAuF,QAAQ,EADjG;;AAGA;AACD;;AAED,WAAK,OAAL,CAAa,IAAb,CAAkB,6BAAlB;;AACA,WAAK,OAAL,CAAa,IAAb,EAAmB,KAAnB;AACD,KAjBD;AAkBD;;AAzGiD,C","sourcesContent":["import { AllPublishOptions } from \"builder-util-runtime\";\nimport { AppAdapter } from \"./AppAdapter\";\nimport { AppUpdater, DownloadExecutorTask } from \"./AppUpdater\";\n\nexport abstract class BaseUpdater extends AppUpdater {\n  protected quitAndInstallCalled = false;\n  private quitHandlerAdded = false;\n\n  protected constructor(options?: AllPublishOptions | null, app?: AppAdapter) {\n    super(options, app);\n  }\n\n  quitAndInstall(isSilent = false, isForceRunAfter = false): void {\n    this._logger.info(`Install on explicit quitAndInstall`);\n    const isInstalled = this.install(\n      isSilent,\n      isSilent ? isForceRunAfter : true\n    );\n    if (isInstalled) {\n      setImmediate(() => {\n        this.app.quit();\n      });\n    } else {\n      this.quitAndInstallCalled = false;\n    }\n  }\n\n  protected executeDownload(\n    taskOptions: DownloadExecutorTask\n  ): Promise<Array<string>> {\n    return super.executeDownload({\n      done: async event => {\n        this.dispatchUpdateDownloaded(event);\n        this.addQuitHandler();\n      },\n      ...taskOptions\n    });\n  }\n\n  // must be sync\n  protected abstract doInstall(options: InstallOptions): boolean;\n\n  // must be sync (because quit even handler is not async)\n  protected install(isSilent: boolean, isForceRunAfter: boolean): boolean {\n    if (this.quitAndInstallCalled) {\n      this._logger.warn(\n        \"install call ignored: quitAndInstallCalled is set to true\"\n      );\n      return false;\n    }\n\n    const downloadedUpdateHelper = this.downloadedUpdateHelper;\n    const installerPath =\n      downloadedUpdateHelper == null ? null : downloadedUpdateHelper.file;\n    const downloadedFileInfo =\n      downloadedUpdateHelper == null\n        ? null\n        : downloadedUpdateHelper.downloadedFileInfo;\n    if (installerPath == null || downloadedFileInfo == null) {\n      this.dispatchError(\n        new Error(\"No valid update available, can't quit and install\")\n      );\n      return false;\n    }\n\n    // prevent calling several times\n    this.quitAndInstallCalled = true;\n\n    try {\n      this._logger.info(\n        `Install: isSilent: ${isSilent}, isForceRunAfter: ${isForceRunAfter}`\n      );\n      return this.doInstall({\n        installerPath,\n        isSilent,\n        isForceRunAfter,\n        isAdminRightsRequired: downloadedFileInfo.isAdminRightsRequired\n      });\n    } catch (e) {\n      this.dispatchError(e);\n      return false;\n    }\n  }\n\n  protected addQuitHandler(): void {\n    if (this.quitHandlerAdded || !this.autoInstallOnAppQuit) {\n      return;\n    }\n\n    this.quitHandlerAdded = true;\n\n    this.app.onQuit(exitCode => {\n      if (this.quitAndInstallCalled) {\n        this._logger.info(\n          \"Update installer has already been triggered. Quitting application.\"\n        );\n        return;\n      }\n\n      if (exitCode !== 0) {\n        this._logger.info(\n          `Update will be not installed on quit because application is quitting with exit code ${exitCode}`\n        );\n        return;\n      }\n\n      this._logger.info(\"Auto install update on quit\");\n      this.install(true, false);\n    });\n  }\n}\n\nexport interface InstallOptions {\n  readonly installerPath: string;\n  readonly isSilent: boolean;\n  readonly isForceRunAfter: boolean;\n  readonly isAdminRightsRequired: boolean;\n}\n"],"sourceRoot":""}
